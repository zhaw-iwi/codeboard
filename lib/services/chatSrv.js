/**
 *
 * @author Janick Michot
 * @date 27.12.2019
 */

const Sequelize = require('sequelize');
const Op = Sequelize.Op;
const { ChatLine, User, HelpRequest, Course, Project } = require('../models');
const userSrv = require('../services/userSrv.js');
const mailSrv = require('../services/mailSrv.js');

/**
 * Return chatline with user and author included
 *
 * @param chatLineId
 * @returns {void|Query|Promise<Model | null>|Promise<Model>}
 */
const getChatLine = function (chatLineId) {
  return ChatLine.findOne({
    where: { id: chatLineId },
    include: [
      { model: User, as: 'user', attributes: ['username', 'name', 'email', 'emailPublic'] },
      { model: User, as: 'author', attributes: ['username'] },
      {
        model: HelpRequest,
        as: 'subject',
        required: false,
        attributes: ['status'],
        include: [{ model: Course, as: 'course', attributes: ['id', 'coursename'] }],
      },
      { model: Project, as: 'project', attributes: ['projectname'] },
    ],
  });
};

/**
 * Return all chatlines of type hint or hintChatbot for a specific user and project
 *
 * @param userId
 * @param projectId
 * @returns {Promise<*>}
 */
const getHintChatLinesForProject = async function (userId, projectId) {
  var hintContent = {};
  const hints = await ChatLine.findAll({
    where: {
      userId: userId,
      ProjectId: projectId,
      [Op.or]: [{ type: 'hintChatbot' }, { type: 'hint' }],
    },
  });

  if (hints.length === 0) {
    return hintContent;
  }

  for (const hint of hints) {
    const { cardHeader, cardBody } = JSON.parse(hint.message) || {};
    if (cardHeader && cardBody) {
      hintContent[cardHeader] = cardBody;
    }
  }

  // return the hint history as an string
  return JSON.stringify(hintContent, null, 2);
};

/**
 * Returns all chatlines for user and project
 *
 * @param username
 * @param projectId
 */
const getChatLines = function (username, projectId) {
  return userSrv.getUser(username).then(function (projectUser) {
    return ChatLine.findAll({
      where: {
        userId: projectUser.id,
        projectId: projectId,
      },
      include: [
        { model: User, as: 'user', attributes: ['username', 'name'] },
        { model: User, as: 'author', attributes: ['username', 'name'] },
        { model: HelpRequest, as: 'subject', attributes: ['status'] },
      ],
    });
  });
};

/**
 * Creates a new chatline
 *
 * @param user
 * @param projectId
 * @param options obj{author, message, messageType, helpRequestId}
 * @returns {*}
 */
const addChatLine = function (user, projectId, options = {}) {
  // create promises
  let getAuthor = userSrv.getUser(options.author);
  let projectUser = userSrv.getUser(user);
  let aChatLine;

  // create chatLine after author und projectUser are loaded
  return Promise.all([getAuthor, projectUser])
    .then(function ([author, projectUser]) {
      // todo was passiert wenn kein author?

      // create chatline
      let chatLine = ChatLine.build({
        userId: projectUser.id,
        ProjectId: projectId,
        authorId: author.id,
        type: options.messageType,
        message: options.message,
      });

      // set subject (helprequest)
      if (options.helpRequestId && options.helpRequestId > 0) {
        chatLine.setSubject(options.helpRequestId, { save: false });
      }

      // return new chatLine
      return chatLine.save();
    })
    .then(function (chatLine) {
      // reload chatline to get subject
      return getChatLine(chatLine.id).then(function (chatLine) {
        aChatLine = chatLine;

        // When authorId is not equal to userId the we assume that the teacher has sent an answer.
        // In this case we send a mail to the student with the information that a reply has been received
        // exception: the !Roby check ensures that no mail is sent to the student if the answer is generated by the llm
        if (aChatLine.authorId !== aChatLine.userId && chatLine.author.username !== 'Roby') {
          mailSrv
            .sendTeacherAddedAnswerMail(
              chatLine.user.emailPublic ? chatLine.user.emailPublic : chatLine.user.email,
              chatLine.user.name ? chatLine.user.name : chatLine.user.username,
              chatLine.project.projectname
            )
            .then(function () {
              return aChatLine;
            });
        }
        // otherwise we send an email to the student with the information about the new  help requests
        // exception: if the type is helpChatbot, we do not send a mail because the answer
        // is generated by the llm
        else if (aChatLine.authorId === aChatLine.userId && chatLine.type !== 'helpChatbot') {
          mailSrv
            .sendStudentRequestsHelpMail(
              chatLine.user.name ? chatLine.user.name : chatLine.user.username,
              chatLine.project.projectname,
              chatLine.subject.course ? chatLine.subject.course.coursename : false,
              JSON.parse(chatLine.message).cardReference
            )
            .then(function () {
              return aChatLine;
            });
        }

        return aChatLine;
      });
    })
    .catch(function (err) {
      console.log(err);
    });
};

/**
 * Updates an existing chatline
 *
 * @param updateData
 * @returns {*}
 */
const updateChatLine = async function (id, updateData) {
  // check if the chatline exists
  const chatLine = await ChatLine.findByPk(id);
  if (!chatLine) {
    throw new Error('ChatLine not found');
  }

  // update the chatline with the new data
  return await ChatLine.update(updateData, {
    where: { id: id },
  });
};

// export the service functions
module.exports = {
  getChatLine,
  getHintChatLinesForProject,
  getChatLines,
  addChatLine,
  updateChatLine,
};
